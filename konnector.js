// Generated by CoffeeScript 1.12.5
(function() {
  var BaseKonnector, Bill, Client, ConsumptionStatement, Contract, File, Folder, Home, K, PaymentTerms, _edfRequestPost, _extend, async, buildNotifContent, builder, createNewFile, displayData, edfRequestPost, fetchEdeliaData, fetchEdeliaElecIndexes, fetchEdeliaGasIndexes, fetchEdeliaMonthlyElecConsumptions, fetchEdeliaMonthlyGasConsumptions, fetchEdeliaProfile, fetchEdeliaSimilarHomeYearlyElecComparisions, fetchEdeliaSimilarHomeYearlyGasComparisions, fetchEdeliaToken, fetchListerContratClientParticulier, fetchPDF, fetchRecupereDocumentContractuelListx, fetchVisualiserAccordCommercial, fetchVisualiserCalendrierPaiement, fetchVisualiserHistoConso, fetchVisualiserPartenaire, fetcher, getEDFToken, getEdelia, getF, konnectorLibs, logger, moment, parser, prepareEntries, request, saveMissingBills, translate, updateOrCreate, xml2js,
    slice = [].slice;

  xml2js = require('xml2js');

  request = require('request');

  async = require('async');

  moment = require('moment');

  updateOrCreate = require('./lib/update_or_create');

  konnectorLibs = require('cozy-konnector-libs');

  fetcher = konnectorLibs.fetcher;

  BaseKonnector = konnectorLibs.baseKonnector;

  File = konnectorLibs.models.file;

  Folder = konnectorLibs.models.folder;

  Bill = konnectorLibs.models.bill;

  Client = require('./models/client');

  Contract = require('./models/contract');

  PaymentTerms = require('./models/payment_terms');

  ConsumptionStatement = require('./models/consumption_statement');

  Home = require('./models/home');

  parser = new xml2js.Parser();

  builder = new xml2js.Builder({
    headless: true
  });

  logger = require('printit')({
    prefix: 'EDF',
    date: true
  });

  getEDFToken = function(requiredFields, entries, data, callback) {
    var body, path;
    K.logger.info('getEDFToken');
    path = "/ws/authentifierUnClientParticulier_rest_V2-0/invoke";
    body = {
      "ns:msgRequete": {
        "$": {
          "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
          "xsi:schemaLocation": "http://www.edf.fr/commerce/" + "passerelle/authentifierUnClientParticulier/service/v2/" + "message authentifierUnClientParticulier.xsd",
          "xmlns:ns": "http://www.edf.fr/commerce/passerelle/" + "authentifierUnClientParticulier/service/v2/message"
        },
        "ns:enteteEntree": [
          {
            "ns:idCanal": 5
          }
        ],
        "ns:corpsEntree": [
          {
            "ns:idAppelant": requiredFields.email,
            "ns:password": requiredFields.password
          }
        ]
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var errorCode, token;
      if (err) {
        return callback(err);
      }
      errorCode = getF(result, 'ns:enteteSortie', 'ent:codeRetour');
      if (errorCode && errorCode !== '0000') {
        K.logger.error(getF(result, 'ns:enteteSortie', 'ent:libelleRetour '));
      }
      token = getF(result['ns:msgReponse'], 'ns:corpsSortie', 'ns:jeton');
      if (token != null) {
        K.logger.info("EDF token fetched");
        data.edfToken = token;
        return callback();
      } else {
        K.logger.error("Can't fetch EDF token");
        return callback('token not found');
      }
    });
  };

  fetchListerContratClientParticulier = function(reqFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetch listerContratClientParticulier");
    path = '/ws/listerContratClientParticulier_rest_V4-0/invoke';
    body = {
      'msgRequete': {
        '$': {
          'xmlns': "http://www.edf.fr/commerce/passerelle/pas072/" + "listerContratClientParticulier/service/v3",
          'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance",
          'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "pas072/listerContratClientParticulier/service/" + "v3 listerContratClientParticulier.xsd"
        },
        'EnteteEntree': {
          'Jeton': data.edfToken
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var addressObject, bpObject, civilite, client, coHolder, coTitulaireElem, codePostal, contracts, contratElems, e, errorCode, identiteObj, nom, nomRue, numRue, prenom, resBody, ville;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result, 'tns:EnteteSortie', 'tns:CodeErreur');
        if (errorCode && errorCode !== 'PSC0000') {
          K.logger.error(getF(result, 'tns:EnteteSortie', 'tns:LibelleErreur'));
          return callback('request error');
        }
        client = {
          vendor: 'EDF',
          docTypeVersion: K.docTypeVersion
        };
        resBody = getF(result["tns:msgReponse"], "tns:CorpsSortie", 'tns:AccordCo');
        client.numeroAcc = getF(resBody, 'tns:Numero');
        bpObject = getF(resBody, 'tns:BP');
        client.clientId = getF(bpObject, 'tns:Numero');
        addressObject = getF(resBody, 'tns:Adresse');
        if (addressObject) {
          numRue = getF(addressObject, 'tns:NumRue') || "";
          nomRue = getF(addressObject, 'tns:NomRue') || "";
          codePostal = getF(addressObject, 'tns:CodePostal') || "";
          ville = getF(addressObject, 'tns:Ville') || "";
          client.address = {
            street: numRue + " " + nomRue,
            city: ville,
            postcode: codePostal,
            country: 'FRANCE',
            formated: numRue + " " + nomRue + "\n" + codePostal + " " + ville
          };
        }
        identiteObj = getF(bpObject, 'tns:Identite');
        civilite = getF(identiteObj, 'tns:Civilite') || '';
        nom = getF(identiteObj, 'tns:Nom') || '';
        prenom = getF(identiteObj, 'tns:Prenom') || '';
        client.name = {
          prefix: civilite,
          family: nom,
          given: prenom,
          formated: prenom + " " + nom
        };
        coTitulaireElem = getF(bpObject, 'tns:IdentitePart');
        if (coTitulaireElem) {
          coHolder = {
            family: getF(coTitulaireElem, 'tns:NomCoTitulaire'),
            given: getF(coTitulaireElem, 'tns:PrenomCoTitulaire')
          };
          coHolder.formated = coHolder.given + " " + coHolder.family;
          client.coHolder = coHolder;
        }
        client.email = getF(bpObject, 'tns:Coordonnees', 'tns:Email');
        client.cellPhone = getF(bpObject, 'tns:Coordonnees', 'tns:NumTelMobile');
        contratElems = resBody['tns:Contrat'];
        contracts = contratElems.map(function(contratElem) {
          var cadranElem, contract, counter, offreSouscriteObj, releveElem, services, statement, vieContratObj;
          contract = {
            vendor: 'EDF',
            clientId: client.clientId,
            docTypeVersion: K.docTypeVersion
          };
          contract.number = getF(contratElem, 'tns:Numero');
          contract.pdl = getF(contratElem, 'tns:NumeroPDL');
          vieContratObj = getF(contratElem, 'tns:VieDuContrat');
          contract.start = getF(vieContratObj, 'tns:DateDebut');
          contract.status = getF(vieContratObj, 'tns:Statut');
          contract.end = getF(vieContratObj, 'tns:DateFin');
          contract.terminationGrounds = getF(vieContratObj, 'tns:MotifResiliation');
          offreSouscriteObj = getF(contratElem, 'tns:OffreSouscrite');
          contract.energie = translate({
            ELECTRICITE: 'Électricité',
            GAZ: 'Gaz'
          }, getF(offreSouscriteObj, 'tns:Energie'));
          contract.name = translate({
            GN_2: 'Offre Gaz naturel',
            MCGN_2: 'Mon Contrat gaz naturel',
            MCGN_PRIX_FIXE_1: 'Mon Contrat Gaz Naturel a prix fixe',
            ELECTRICITE_PRO: 'Electricite Pro',
            ELEC_DEREGULE: 'Mon Contrat Electricite',
            ELEC_PRO_PX_FIXE_1: 'Electricite Pro a Prix Fixe',
            ESSENTIEL_PRO: 'Essentiel Pro',
            OFFRE_HC_SOUPLES: 'Heures Creuses Souples',
            PRESENCE_PRO: 'Presence Pro',
            SOUPLESSE_PRO: 'Souplesse Pro',
            TARIF_BLEU: 'Tarif Bleu',
            TARIF_BLEU_PART: 'Tarif Bleu',
            ESSENTIEL_GAZ: 'Essentiel Gaz',
            GAZ: 'Mon Contrat Gaz Naturel',
            GAZ_2: 'Mon Contrat Gaz Naturel',
            GAZ_NAT_PX_FIXE_1: 'Gaz Naturel a Prix Fixe',
            PRESENCE_GAZ: 'Presence Gaz',
            SOUPLESSE_GAZ: 'Souplesse Gaz',
            TARIF_BLEU_GAZ: 'Gaz Naturel',
            TARIF_EJP_PART: 'EJP',
            OFFRE_TPN: 'TPN'
          }, getF(offreSouscriteObj, 'tns:NomOffre'));
          contract.troubleshootingPhone = getF(offreSouscriteObj, 'tns:NumeroDepannageContrat');
          switch (contract.energie) {
            case 'Électricité':
              contract.power = translate({
                PUI00: '0 kVA',
                PUI03: '3 kVA',
                PUI06: '6 kVA',
                PUI09: '9 kVA',
                PUI12: '12 kVA',
                PUI15: '15 kVA',
                PUI18: '18 kVA',
                PUI24: '24 kVA',
                PUI30: '30 kVA',
                PUI36: '36 kVA'
              }, getF(offreSouscriteObj, 'tns:Puissance'));
              contract.contractSubcategory1 = getF(offreSouscriteObj, 'tns:StructureTarifaire');
              break;
            case 'Gaz':
              contract.contractSubcategory2 = getF(offreSouscriteObj, 'tns:OptionPrix');
          }
          cadranElem = getF(contratElem, 'tns:ListeCadran');
          if (cadranElem) {
            counter = {};
            counter.comptage = getF(cadranElem, 'tns:Type');
            counter.nombreRoues = getF(cadranElem, 'tns:NombreRoues');
            counter.dernierIndex = getF(cadranElem, 'tns:DernierIndex');
            counter.type = getF(contratElem, 'tns:DonneesTechniques', 'tns:TypeCompteur');
            contract.counter = counter;
            contract.annualConsumption = getF(cadranElem, 'tns:ConsommationAnnuelle');
          }
          contract.peakHours = getF(contratElem, 'tns:DonneesTechniques', 'tns:HorrairesHC');
          releveElem = getF(contratElem, 'tns:Releve');
          if (releveElem) {
            statement = {};
            statement.prochaineReleve = getF(releveElem, 'tns:ProchaineDateReleveReelle');
            statement.saisieReleveConfiance = getF(releveElem, 'tns:SaisieRC');
            statement.dateFermetureReleveConfiance = getF(releveElem, 'tns:DateFermetureRC');
            statement.prochaineDateOuvertureReleveConfiance = getF(releveElem, 'tns:ProchaineDateOuvertureRC');
            statement.prochaineDateFermetureReleveConfiance = getF(releveElem, 'tns:ProchaineDateFermetureRC');
            statement.prochaineDateFermetureReelle = getF(releveElem, 'tns:ProchaineDateFermetureReelle');
            statement.saisieSuiviConso = getF(releveElem, 'tns:SaisieSC');
            statement.prochaineDateOuvertureSaisieConso = getF(releveElem, 'tns:ProchaineDateOuvertureSC');
            contract.statement = statement;
          }
          contract.services = [];
          if (contratElem['tns:ServicesSouscrits']) {
            services = contratElem['tns:ServicesSouscrits'].map(function(serviceElem) {
              var service;
              service = {
                nom: getF(serviceElem, 'tns:NomService'),
                activ: getF(serviceElem, 'tns:Etat')
              };
              return service;
            });
            contract.services = contract.services.concat(services);
          }
          if (resBody['tns:ServicesSouscrits']) {
            services = resBody['tns:ServicesSouscrits'].map(function(serviceElem) {
              var service;
              service = {
                nom: getF(serviceElem, 'tns:nomService'),
                start: getF(serviceElem, 'tns:dateSouscription'),
                activ: getF(serviceElem, 'tns:statut')
              };
              return service;
            });
            contract.services = contract.services.concat(services);
          }
          return contract;
        });
        K.logger.info("Fetched listerContratClientParticulier");
        entries.clients.push(client);
        entries.contracts = contracts;
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetching listerContratClientParticulier", e);
        return callback(e);
      }
    });
  };

  fetchVisualiserPartenaire = function(requiredFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetchVisualiserPartenaire");
    path = '/ws/visualiserPartenaire_rest_V2-0/invoke';
    body = {
      'msgRequete': {
        '$': {
          'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserPartenaire/service/v2 C:\\HMN\\EDFMoiV2\\WSDL" + "\\passerelle\\passerelle\\css\\visualiserPartenaire\\service" + "\\v2\\visualiserPartenaire.xsd",
          'xmlns': "http://www.edf.fr/commerce/passerelle/css/" + "visualiserPartenaire/service/v2",
          'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete",
          'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
        },
        'enteteEntree': {
          'ent:jeton': data.edfToken
        },
        'corpsEntree': {
          'numeroBp': entries.clients[0].clientId
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var address, addressElem, client, contact, contactElem, coordonneesElem, e, errorCode, partnerElem;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result, 'ns:enteteSortie', 'ent:codeRetour');
        if (errorCode && errorCode !== '0') {
          K.logger.error(getF(result, 'tns:enteteSortie', 'tns:libelleRetour'));
          return callback();
        }
        partnerElem = getF(result["ns:msgReponse"], "ns:corpsSortie", "ns:partenaire");
        client = {};
        coordonneesElem = getF(partnerElem, 'ns:coordonnees');
        client.cellPhone = getF(coordonneesElem, 'ns:NumTelMobile');
        client.homePhone = getF(coordonneesElem, 'ns:NumTelFixe');
        client.email = getF(coordonneesElem, 'ns:Email');
        client.loginEmail = getF(coordonneesElem, 'ns:EmailAEL');
        contactElem = getF(partnerElem, 'ns:centreContact');
        contact = {};
        contact.title = getF(contactElem, 'ns:gsr');
        contact.phone = getF(contactElem, 'ns:telephone');
        addressElem = getF(contactElem, 'ns:adresse');
        if (addressElem) {
          address = {};
          address.street = getF(addressElem, 'ns:nomRue');
          address.postcode = getF(addressElem, 'ns:codePostal');
          address.city = getF(addressElem, 'ns:ville');
          address.formated = ("" + address.street) + ("\n" + address.postcode + " " + address.city);
          contact.address = address;
        }
        client.commercialContact = contact;
        entries.clients[0] = _extend(entries.clients[0], client);
        K.logger.info("Fetched visualiserPartenaire.");
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetching visualiserPartenaire.");
        K.logger.error(e);
        return callback(e);
      }
    });
  };

  fetchVisualiserAccordCommercial = function(requiredFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetchVisualiserAccordCommercial");
    path = '/ws/visualiserAccordCommercial_rest_V2-0/invoke';
    body = {
      'msg:msgRequete': {
        '$': {
          'xmlns:dico': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/dico",
          'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/v2" + "/entete",
          'xmlns:msg': "http://www.edf.fr/commerce/passerelle/css/" + "visualiserAccordCommercial/service/v2",
          'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance",
          'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserAccordCommercial/service/" + "v2 visualiserAccordCommercial.xsd"
        },
        'msg:enteteEntree': {
          'ent:jeton': data.edfToken
        },
        'msg:corpsEntree': {
          'msg:numeroBp': entries.clients[0].clientId,
          'msg:numeroAcc': entries.clients[0].numeroAcc
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var acoElem, bankAddress, bankDetails, e, errorCode, paymentTerms, services, servicesElem;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result, 'ns:enteteSortie', 'ent:codeErreur');
        if (errorCode && errorCode !== '0') {
          K.logger.error(getF(result, 'tns:enteteSortie', 'tns:libelleErreur'));
          return callback();
        }
        acoElem = getF(result["ns:msgReponse"], "ns:corpsSortie", "ns:listeAccordCommerciaux", "ns:acordcommercial");
        paymentTerms = {
          vendor: 'EDF',
          clientId: entries.clients[0].clientId,
          docTypeVersion: K.docTypeVersion
        };
        bankDetails = {
          iban: getF(acoElem, 'ns:banque', 'ns:iban'),
          holder: getF(acoElem, 'ns:compte', 'ns:titulaire'),
          bank: getF(acoElem, "ns:banque", "ns:nom")
        };
        bankAddress = {
          street: getF(acoElem, 'ns:banque', 'ns:numNomRue'),
          city: getF(acoElem, 'ns:banque', 'ns:codePostalVille'),
          country: getF(acoElem, 'ns:banque', 'ns:pays')
        };
        bankAddress.formated = ("" + bankAddress.street) + ("\n" + bankAddress.city + " " + bankAddress.country);
        bankDetails.bankAddress = bankAddress;
        paymentTerms.encryptedBankDetails = JSON.stringify(bankDetails);
        paymentTerms.balance = getF(acoElem, 'ns:detail', 'ns:solde');
        paymentTerms.paymentMeans = getF(acoElem, 'ns:detail', 'ns:modeEncaissement');
        paymentTerms.modifBankDetailsAllowed = getF(acoElem, 'ns:detail', 'ns:modifIbanAutorisee');
        paymentTerms.dernierReglement = {
          date: getF(acoElem, 'ns:dernierReglement', 'ns:date'),
          amount: getF(acoElem, 'ns:dernierReglement', 'ns:montant'),
          type: getF(acoElem, 'ns:dernierReglement', 'ns:type')
        };
        paymentTerms.billFrequency = getF(acoElem, 'ns:facturation', 'ns:periodicite');
        paymentTerms.nextBillDate = getF(acoElem, 'ns:facturation', 'ns:dateProchaineFacture');
        paymentTerms.idPayer = getF(acoElem, 'ns:numeroPayeur');
        paymentTerms.payerDivergent = getF(acoElem, 'ns:payeurDivergent');
        servicesElem = acoElem['ns:services'];
        services = servicesElem.map(function(serviceElem) {
          var service;
          service = {};
          service.name = getF(serviceElem, 'ns:nomService');
          service.status = getF(serviceElem, 'ns:etat');
          service.valueSubscribed = getF(serviceElem, 'ns:valeurSouscrite');
          service.valuesAvailable = serviceElem['ns:valeursPossibles'];
          return service;
        });
        entries.paymenttermss.push(paymentTerms);
        entries.contracts.forEach(function(contract) {
          return contract.services = contract.services.concat(services);
        });
        K.logger.info("Fetched visualiserAccordCommercial.");
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetching visualiserAccordCommercial.");
        K.logger.error(e);
        return callback(e);
      }
    });
  };

  fetchVisualiserCalendrierPaiement = function(requiredFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetchVisualiserCalendrierPaiement");
    path = '/ws/visualiserCalendrierPaiement_rest_V2-0/invoke';
    body = {
      'message:msgRequete': {
        '$': {
          'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserCalendrierPaiement/service/v2 C:\\HMN\\" + "EDFMoiV2\\WSDL\\passerelle\\passerelle\\css\\" + "visualiserCalendrierPaiement\\service\\v2\\" + "visualiserCalendrierPaiement.xsd",
          'xmlns:message': "http://www.edf.fr/commerce/passerelle/css/" + "visualiserCalendrierPaiement/service/v2",
          'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete",
          'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
        },
        'message:enteteEntree': {
          'ent:jeton': data.edfToken
        },
        'message:corpsEntree': {
          'message:numeroBp': entries.clients[0].clientId,
          'message:numeroAcc': entries.clients[0].numeroAcc
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var e, errorCode, listeEcheances, paymentSchedules;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result, 'ns:msgReponse', 'ns:enteteSortie', 'ent:codeRetour');
        if (errorCode && errorCode !== '0') {
          K.logger.error(getF(result, 'ns:msgReponse', 'ns:enteteSortie', 'ent:libelleRetour'));
          return callback();
        }
        listeEcheances = getF(result["ns:msgReponse"], "ns:corpsSortie", "ns:calendrierDePaiement");
        if (!(listeEcheances && listeEcheances['ns:listeEcheances'] && listeEcheances['ns:listeEcheances'].length > 0)) {
          K.logger.warn('No payment schedules');
          return callback();
        }
        listeEcheances = listeEcheances["ns:listeEcheances"];
        paymentSchedules = listeEcheances.map(function(echeance) {
          var amountElec, amountGaz, doc;
          amountGaz = parseFloat(getF(echeance, "ns:montantGaz"));
          amountElec = parseFloat(getF(echeance, "ns:montantElec"));
          if (isNaN(amountGaz)) {
            amountGaz = 0;
          }
          if (isNaN(amountElec)) {
            amountElec = 0;
          }
          doc = {
            number: parseInt(getF(echeance, "ns:numeroEcheance")),
            receiptDate: getF(echeance, "ns:dateEncaissement"),
            scheduleDate: getF(echeance, "ns:DateEcheance"),
            paid: getF(echeance, "ns:paiement") === 'EFFECTUE',
            amount: amountGaz + amountElec,
            amountGas: amountGaz,
            amountElectricity: amountElec
          };
          return doc;
        });
        if (!entries.paymenttermss[0]) {
          entries.paymenttermss[0] = {
            vendor: 'EDF',
            clientId: entries.clients[0].clientId,
            docTypeVersion: K.docTypeVersion
          };
        }
        entries.paymenttermss[0].paymentSchedules = paymentSchedules;
        K.logger.info(("Fetched " + paymentSchedules.length + " ") + "from fetchVisualiserCalendrierPaiement");
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetchVisualiserCalendrierPaiement");
        K.logger.error(e);
        return callback(e);
      }
    });
  };

  fetchRecupereDocumentContractuelListx = function(reqFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetchRecupereDocumentContractuelListx");
    path = '/ws/recupererDocumentContractuelListx_rest_V1-0/invoke';
    body = {
      'ns:msgRequete': {
        '$': {
          'xmlns:dicoPAS': "http://www.edf.fr/commerce/passerelle/" + "commun/v2/dico",
          'xmlns:dico': "http://www.edf.fr/psc/pscmaxsd/commun/v1/dico",
          'xmlns:ns': "http://www.edf.fr/commerce/passerelle/psc/" + "recupererDocumentContractuelListx/service/v1",
          'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete"
        },
        'ns:jeton': data.edfToken,
        'ns:options': [
          {
            'ns:cle': 'id',
            'ns:valeur': 'pscedfmoi'
          }, {
            'ns:cle': 2,
            'ns:valeur': entries.clients[0].clientId
          }, {
            'ns:cle': 6,
            'ns:valeur': 'Facture'
          }
        ]
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var bills, documents, e;
      if (err) {
        return callback(err);
      }
      bills = [];
      try {
        documents = result["ns:msgReponse"]["ns:docubase"][0]["ns:document"];
        bills = documents.map(function(elem) {
          var bill, date, i, key, len, option, ref, value;
          bill = {
            vendor: 'EDF',
            clientId: entries.clients[0].clientId,
            docTypeVersion: K.docTypeVersion
          };
          date = moment(getF(elem, 'ns:datecre'), 'YYYYMMDD');
          bill.date = date.format('YYYY-MM-DD');
          ref = elem['ns:category'];
          for (i = 0, len = ref.length; i < len; i++) {
            option = ref[i];
            key = getF(option, 'ns:id');
            value = getF(option, 'ns:valeur');
            switch (key) {
              case '4':
                bill.number = value;
                break;
              case '7':
                bill.amount = Number(value);
            }
          }
          return bill;
        });
        entries.bills = bills;
        K.logger.info("Fetched " + bills.length + " bills");
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetchRecupereDocumentContractuelListx");
        K.logger.error(e);
        return callback(e);
      }
    });
  };

  fetchVisualiserHistoConso = function(requiredFields, entries, data, callback) {
    K.logger.info("fetchVisualiserHistoConso");
    return async.mapSeries(entries.contracts, function(contract, cb) {
      var body, path;
      path = '/ws/visualiserHistoConso_rest_V3-0/invoke';
      body = {
        'message:msgRequete': {
          '$': {
            'xsi:schemaLocation': "http://www.edf.fr/commerce/" + "passerelle/css/visualiserHistoConso/service/v2 C:\\HMN" + "\\EDFMoiV2\\WSDL\\passerelle\\passerelle\\css" + "\\visualiserHistoConso\\service\\v2\\" + "visualiserHistoConso.xsd",
            'xmlns:message': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserHistoConso/service/v2",
            'xmlns:ent': "http://www.edf.fr/commerce/passerelle/" + "commun/v2/entete",
            'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
          },
          'message:enteteEntree': {
            'ent:jeton': data.edfToken
          },
          'message:corpsEntree': {
            'message:numeroBp': entries.clients[0].clientId,
            'message:numeroContrat': contract.number
          }
        }
      };
      return edfRequestPost(path, body, function(err, result) {
        var consoElems, e, errorCode, res;
        if (err) {
          return callback(err);
        }
        try {
          errorCode = getF(result, 'ns:enteteSortie', 'ent:codeRetour');
          if (errorCode && errorCode !== '0') {
            K.logger.error(getF(result, 'tns:enteteSortie', 'tns:libelleRetour'));
            return callback();
          }
          if (!("ns:corpsSortie" in result["ns:msgReponse"])) {
            K.logger.info("No histoConsos to fetch");
            return callback(null, []);
          }
          consoElems = result["ns:msgReponse"]["ns:corpsSortie"][0]["ns:listeHistoDeConso"];
          res = consoElems.map(function(consoElem) {
            var doc;
            doc = {
              contractNumber: contract.number,
              billNumber: getF(consoElem, 'ns:numeroFacture'),
              start: getF(consoElem, 'ns:dateDebut'),
              end: getF(consoElem, 'ns:dateFin'),
              value: getF(consoElem, 'ns:listeConsommation', 'ns:valeur'),
              statementType: getF(consoElem, 'ns:typeReleve'),
              statementCategory: getF(consoElem, 'ns:categorieReleve'),
              statementReason: getF(consoElem, 'ns:motifReleve'),
              docTypeVersion: K.docTypeVersion
            };
            return doc;
          });
          return cb(null, res);
        } catch (error1) {
          e = error1;
          K.logger.error("While fetching visualiserHistoConso.");
          K.logger.error(e);
          return cb(e);
        }
      });
    }, function(err, results) {
      if (err) {
        return callback(err);
      }
      entries.consumptionstatements = results.reduce(function(agg, result) {
        return agg.concat(result);
      }, []);
      K.logger.info(("Fetched " + entries.consumptionstatements.length) + " consumptionStatements");
      return callback();
    });
  };

  fetchPDF = function(token, client, billNumber, callback) {
    var body, path;
    K.logger.info("fetchPDF");
    path = '/ws/recupererDocumentContractuelGet_rest_V1-0/invoke';
    body = {
      'ns:msgRequete': {
        '$': {
          'xmlns:dicoPAS': "http://www.edf.fr/commerce/passerelle/" + "commun/v2/dico",
          'xmlns:dico': "http://www.edf.fr/psc/pscmaxsd/commun/v1/dico",
          'xmlns:ns': "http://www.edf.fr/commerce/passerelle/psc/" + "recupererDocumentContractuelGet/service/v1",
          'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete"
        },
        'ns:jeton': token,
        'ns:options': [
          {
            'ns:cle': 'id',
            'ns:valeur': 'pscedfmoi'
          }, {
            'ns:cle': 2,
            'ns:valeur': client.clientId
          }, {
            'ns:cle': 4,
            'ns:valeur': billNumber
          }, {
            'ns:cle': 6,
            'ns:valeur': 'Facture'
          }
        ]
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var base64PDF;
      if (err) {
        return callback(err);
      }
      K.logger.info("pdf fetched");
      base64PDF = getF(result['ns:msgReponse'], 'ns:docubase', 'ns:documentPDF', 'ns:pdf');
      return callback(null, base64PDF);
    });
  };

  fetchEdeliaToken = function(requiredFields, entries, data, callback) {
    K.logger.info("fetchEdeliaToken");
    return request.post('https://api.edelia.fr/authorization-server/oauth/token', {
      form: {
        client_id: 'sha1pae0Pahngee6uwiphooDie7thaiquahf2xohd6IeFeiphi9ziu0uw3am',
        grant_type: 'edf_sso',
        jeton_sso: data.edfToken,
        bp: entries.clients[0].clientId,
        pdl: data.contract.pdl
      },
      json: true
    }, function(err, response, result) {
      if (err) {
        K.logger.error('While fetching edelia token.');
        K.logger.error(err);
        return callback(err);
      }
      K.logger.info('Fetched edelia token');
      data.edeliaToken = result.access_token;
      return callback();
    });
  };

  fetchEdeliaProfile = function(requiredFields, entries, data, callback) {
    K.logger.info("fetchEdeliaProfile");
    return getEdelia(data.edeliaToken, '/sites/-/profiles/simple?ts=' + new Date().toISOString(), function(err, response, obj) {
      var doc, e, error;
      error = null;
      try {
        if (!err && !obj) {
          err = 'no import performed';
        }
        if (err) {
          K.logger.error('While fetchEdeliaProfile');
          K.logger.error(err);
          throw err;
        }
        if (obj.errorCode && obj.errorCode === "403") {
          data.noEdelia = true;
          K.logger.warn("No edelia: " + obj.errorDescription);
          throw new Error('no edelia');
        }
        doc = {
          pdl: data.pdl,
          beginTs: obj.beginTs,
          isProfileValidated: obj.isProfileValidated,
          housingType: obj.housingType,
          residenceType: obj.residenceType,
          occupationType: obj.occupationType,
          constructionDate: obj.constructionDate,
          isBBC: obj.isBBC,
          surface: obj.surfaceInSqMeter,
          occupantsCount: obj.noOfOccupants,
          principalHeatingSystemType: obj.principalHeatingSystemType,
          sanitoryHotWaterType: obj.sanitoryHotWaterType,
          docTypeVersion: K.docTypeVersion
        };
        entries.homes.push(doc);
        return K.logger.info('Fetched fetchEdeliaProfile');
      } catch (error1) {
        e = error1;
        return error = e;
      } finally {
        callback(error);
      }
    });
  };

  fetchEdeliaMonthlyElecConsumptions = function(requiredFields, entries, data, callback) {
    if (data.noEdelia) {
      return callback();
    }
    K.logger.info("fetchEdeliaMonthlyElecConsumptions");
    return getEdelia(data.edeliaToken, "/sites/-/monthly-elec-consumptions?" + "begin-month=2012-01&" + ("end-month=" + (moment().add(1, 'month').format('YYYY-MM')) + "&ended=false"), function(err, response, obj) {
      var e, error, statements;
      error = null;
      try {
        if (response.statusCode === 404 || response.statusCode === 500) {
          K.logger.warn('No EdeliaMonthlyElecConsumptions');
          data.noElec = true;
          throw null;
        }
        if (err) {
          K.logger.error('Wihle fetchEdeliaMonthlyElecConsumptions');
          K.logger.error(err);
          throw err;
        }
        statements = [];
        data.consumptionStatementByMonth = {};
        statements = statements.concat(obj.monthlyElecEnergies.map(function(mee) {
          var doc;
          doc = {
            docTypeVersion: K.docTypeVersion,
            contractNumber: data.contract.number,
            start: mee.beginDay,
            end: mee.endDay,
            value: mee.consumption.energy,
            statementType: 'estime',
            statementCategory: 'edelia',
            statementReason: 'EdeliaMonthlyElecConsumption',
            period: mee.month,
            cost: mee.totalCost,
            costsByCategory: mee.consumption.costsByTariffHeading,
            valuesByCatergory: mee.consumption.energiesByTariffHeading
          };
          doc.costsByCategory.standing = mee.standingCharge;
          data.consumptionStatementByMonth[mee.month] = doc;
          return doc;
        }));
        data.consumptionStatementByYear = {};
        statements = statements.concat(obj.yearlyElecEnergies.map(function(yee) {
          var doc;
          doc = {
            docTypeVersion: K.docTypeVersion,
            contractNumber: data.contract.number,
            start: yee.beginDay,
            end: yee.endDay,
            value: yee.consumption.energy,
            statementType: 'estime',
            statementCategory: 'edelia',
            statementReason: 'EdeliaYearlyElecConsumption',
            period: yee.year,
            cost: yee.totalCost,
            costsByCategory: yee.consumption.costsByTariffHeading,
            valuesByCatergory: yee.consumption.energiesByTariffHeading
          };
          doc.costsByCategory.standing = yee.standingCharge;
          data.consumptionStatementByYear[yee.year] = doc;
          return doc;
        }));
        if (statements.length !== 0) {
          entries.consumptionstatements = entries.consumptionstatements.concat(statements);
        }
        return K.logger.info('Fetched fetchEdeliaMonthlyElecConsumptions');
      } catch (error1) {
        e = error1;
        return error = e;
      } finally {
        callback(error);
      }
    });
  };

  fetchEdeliaSimilarHomeYearlyElecComparisions = function(requiredFields, entries, data, callback) {
    if (data.noEdelia || data.noElec) {
      return callback();
    }
    K.logger.info("fetchEdeliaSimilarHomeYearlyElecComparisions");
    return getEdelia(data.edeliaToken, "/sites/-/similar-home-yearly-elec-comparisons?begin-year=2012", function(err, response, objs) {
      var e, error;
      error = null;
      try {
        if (response.statusCode === 404 || response.statusCode === 500) {
          K.logger.warn('No EdeliaSimilarHomeYearlyElecComparisions');
          data.noElec = true;
          throw null;
        }
        if (err) {
          K.logger.error('While fetchEdeliaSimilarHomeYearlyElecComparisions');
          K.logger.error(err);
          throw err;
        }
        objs.forEach(function(obj) {
          var statement;
          statement = data.consumptionStatementByYear[obj.year];
          if (!statement) {
            K.logger.warn("No yearly statement for " + obj.date.year);
            return;
          }
          return statement.similarHomes = {
            site: obj.energies.site,
            average: obj.energies.similarHomes.SH_AVERAGE_CONSUMING,
            least: obj.energies.similarHomes.SH_LEAST_CONSUMING
          };
        });
        K.logger.info('Fetched fetchEdeliaSimilarHomeYearlyElecComparisions');
      } catch (error1) {
        e = error1;
        error = e;
      }
      delete data.consumptionStatementByYear;
      return callback(error);
    });
  };

  fetchEdeliaElecIndexes = function(requiredFields, entries, data, callback) {
    if (data.noEdelia || data.noElec) {
      return callback();
    }
    K.logger.info("fetchEdeliaElecIndexes");
    return getEdelia(data.edeliaToken, "/sites/-/elec-indexes?begin-date=2012-01-01&" + ("end-date=" + (moment().format('YYYY-MM-DD')) + "&types="), function(err, response, objs) {
      var e, error;
      error = null;
      try {
        if (response.statusCode === 404) {
          K.logger.warn('No EdeliaElecIndexes');
          throw null;
        }
        if (err) {
          K.logger.error('Wihle fetchEdeliaElecIndexes');
          K.logger.error(err);
          throw err;
        }
        objs.forEach(function(obj) {
          var statement;
          statement = data.consumptionStatementByMonth[obj.date.slice(0, 7)];
          if (!statement) {
            K.logger.warn("No monthly statement for" + (obj.date.slice(0, 7)));
            return;
          }
          statement.statements = statement.statements || [];
          return statement.statements.push(obj);
        });
        K.logger.info('Fetched fetchEdeliaElecIndexes');
      } catch (error1) {
        e = error1;
        error = e;
      }
      delete data.consumptionStatementByMonth;
      return callback(error);
    });
  };

  fetchEdeliaMonthlyGasConsumptions = function(requiredFields, entries, data, callback) {
    if (data.noEdelia) {
      return callback();
    }
    K.logger.info("fetchEdeliaMonthlyGasConsumptions");
    return getEdelia(data.edeliaToken, "/sites/-/monthly-gas-consumptions?begin-month=2012-01&" + ("end-month=" + (moment().add(1, 'month').format('YYYY-MM')) + "&ended=false"), function(err, response, obj) {
      var e, error, ref, statements;
      error = null;
      try {
        if (response.statusCode === 404) {
          K.logger.warn('No EdeliaMonthlyGasConsumptions');
          data.noGas = true;
          throw null;
        }
        if (err) {
          K.logger.error('Wihle fetchEdeliaMonthlyGasConsumptions');
          K.logger.error(err);
          throw err;
        }
        statements = [];
        data.consumptionStatementByMonth = {};
        statements = (ref = obj.monthlyGasEnergies) != null ? ref.map(function(mee) {
          var doc;
          doc = {
            docTypeVersion: K.docTypeVersion,
            contractNumber: data.contract.number,
            start: mee.beginDay,
            end: mee.endDay,
            value: mee.consumption.energy,
            statementType: 'estime',
            statementCategory: 'edelia',
            statementReason: 'EdeliaMonthlyGasConsumption',
            period: mee.month,
            cost: mee.totalCost,
            costsByCategory: {
              consumption: mee.consumption.cost,
              standing: mee.standingCharge
            }
          };
          data.consumptionStatementByMonth[mee.month] = mee;
          return doc;
        }) : void 0;
        data.consumptionStatementByYear = {};
        statements = statements.concat(obj.yearlyGasEnergies.map(function(yee) {
          var doc;
          doc = {
            docTypeVersion: K.docTypeVersion,
            contractNumber: data.contract.number,
            start: yee.beginDay,
            end: yee.endDay,
            value: yee.consumption.energy,
            statementType: 'estime',
            statementCategory: 'edelia',
            statementReason: 'EdeliaYearlyGasConsumption',
            period: yee.year,
            cost: yee.totalCost,
            costsByCategory: {
              consumption: yee.consumption.cost,
              standing: yee.standingCharge
            }
          };
          data.consumptionStatementByYear[yee.year] = doc;
          return doc;
        }));
        if (statements.length !== 0) {
          entries.consumptionstatements = entries.consumptionstatements.concat(statements);
        }
        K.logger.info('Fetched fetchEdeliaMonthlyGasConsumptions');
      } catch (error1) {
        e = error1;
        error = e;
      }
      return callback(error);
    });
  };

  fetchEdeliaSimilarHomeYearlyGasComparisions = function(requiredFields, entries, data, callback) {
    if (data.noEdelia || data.noGas) {
      return callback();
    }
    K.logger.info("fetchEdeliaSimilarHomeYearlyGasComparisions");
    return getEdelia(data.edeliaToken, "/sites/-/similar-home-yearly-gas-comparisons?begin-year=2012", function(err, response, objs) {
      var e, error;
      error = null;
      try {
        if (response.statusCode === 404 || response.statusCode === 500) {
          K.logger.warn('No EdeliaSimilarHomeYearlyGasComparisions');
          throw null;
        }
        if (err) {
          K.logger.error('While fetchEdeliaSimilarHomeYearlyGasComparisions');
          K.logger.error(err);
          throw err;
        }
        objs.forEach(function(obj) {
          var statement;
          statement = data.consumptionStatementByYear[obj.year];
          if (!statement) {
            K.logger.warn("No yearly statement for " + obj.date.year);
            return;
          }
          return statement.similarHomes = {
            site: obj.energies.site,
            average: obj.energies.similarHomes.SH_AVERAGE_CONSUMING,
            least: obj.energies.similarHomes.SH_LEAST_CONSUMING
          };
        });
        K.logger.info('Fetched fetchEdeliaSimilarHomeYearlyGasComparisions');
      } catch (error1) {
        e = error1;
        error = e;
      }
      return callback(error);
    });
  };

  fetchEdeliaGasIndexes = function(requiredFields, entries, data, callback) {
    if (data.noEdelia || data.noGas) {
      return callback();
    }
    K.logger.info("fetchEdeliaGasIndexes");
    return getEdelia(data.edeliaToken, "/sites/-/gas-indexes?begin-date=2012-01-01&" + ("end-date=" + (moment().format('YYYY-MM-DD')) + "&types="), function(err, response, objs) {
      var e, error;
      error = null;
      try {
        if (response.statusCode === 404) {
          K.logger.warn('No EdeliaGasIndexes');
          throw null;
        }
        if (err) {
          K.logger.error('Wihle fetchEdeliaGasIndexes');
          K.logger.error(err);
          throw err;
        }
        objs.forEach(function(obj) {
          var statement;
          statement = data.consumptionStatementByMonth[obj.date.slice(0, 7)];
          if (!statement) {
            K.logger.warn("No monthly statement for" + (obj.date.slice(0, 7)));
            return;
          }
          statement.statements = statement.statements || [];
          return statement.statements.push(obj);
        });
        K.logger.info('Fetched fetchEdeliaGasIndexes');
      } catch (error1) {
        e = error1;
        error = e;
      }
      return callback(error);
    });
  };

  prepareEntries = function(requiredFields, entries, data, next) {
    entries.homes = [];
    entries.consumptionstatements = [];
    entries.contracts = [];
    entries.bills = [];
    entries.clients = [];
    entries.paymenttermss = [];
    return next();
  };

  buildNotifContent = function(requiredFields, entries, data, next) {
    var addedList, count, docsName, message, ref;
    addedList = [];
    ref = data.created;
    for (docsName in ref) {
      count = ref[docsName];
      if (count > 0) {
        message = localization.t("notification " + docsName, {
          smart_count: count
        });
        addedList.push(message);
      }
    }
    if (addedList.length > 0) {
      entries.notifContent = addedList.join(', ');
    }
    return next();
  };

  createNewFile = function(data, file, callback) {
    var attachBinary;
    attachBinary = function(newFile) {
      file.path = data.name;
      return newFile.attachBinary(file, {
        "name": "file"
      }, function(err, res, body) {
        var upload;
        upload = false;
        if (err) {
          return newFile.destroy(function(error) {
            return callback('file error');
          });
        } else {
          return callback(null, newFile);
        }
      });
    };
    return File.create(data, function(err, newFile) {
      if (err) {
        K.logger.error(err);
        return callback('file error');
      } else {
        return attachBinary(newFile);
      }
    });
  };

  saveMissingBills = function(requiredFields, entries, data, callback) {
    return Bill.all(function(err, bills) {
      return async.eachSeries(bills, function(bill, cb) {
        if ((bill.vendor !== 'EDF') || bill.fileId) {
          return cb();
        }
        return fetchPDF(data.edfToken, entries.clients[0], bill.number, function(err, base64String) {
          var binaryBill, file, name;
          if (err) {
            return cb(err);
          }
          binaryBill = new Buffer(base64String, 'base64');
          name = moment(bill.date).format('YYYY-MM-DD');
          name += '-facture_EDF.pdf';
          file = new File({
            name: name,
            mime: "application/pdf",
            creationDate: new Date().toISOString(),
            lastModification: new Date().toISOString(),
            "class": "document",
            path: requiredFields.folderPath,
            size: binaryBill.length
          });
          return Folder.mkdirp(requiredFields.folderPath, function(err) {
            if (err) {
              return cb('file error');
            }
            return createNewFile(file, binaryBill, function(err, file) {
              var ref;
              if (err) {
                return cb('file error');
              }
              return bill.updateAttributes({
                fileId: file._id,
                binaryId: (ref = file.binary) != null ? ref.file.id : void 0
              }, cb);
            });
          });
        });
      }, callback);
    });
  };

  displayData = function(requiredFields, entries, data, next) {
    K.logger.info("display data");
    K.logger.info(JSON.stringify(entries, null, 2));
    K.logger.info(JSON.stringify(data, null, 2));
    return next();
  };

  fetchEdeliaData = function(requiredFields, entries, data, next) {
    return async.eachSeries(entries.contracts, function(contract, callback) {
      var importer, operations;
      data.contract = contract;
      importer = fetcher["new"]();
      operations = [fetchEdeliaToken, fetchEdeliaProfile, fetchEdeliaMonthlyElecConsumptions, fetchEdeliaSimilarHomeYearlyElecComparisions, fetchEdeliaElecIndexes, fetchEdeliaMonthlyGasConsumptions, fetchEdeliaSimilarHomeYearlyGasComparisions, fetchEdeliaGasIndexes];
      operations.forEach(function(operation) {
        return importer.use(operation);
      });
      importer.args(requiredFields, entries, data);
      return importer.fetch(function(err, fields, entries) {
        if (err && err.message !== 'no edelia') {
          K.logger.error('Error while fetching Edelia data');
          K.logger.error(err);
        }
        return callback();
      });
    }, next);
  };

  K = module.exports = BaseKonnector.createNew({
    name: 'EDF',
    slug: 'edf',
    description: 'konnector description edf',
    vendorLink: 'https://particulier.edf.fr/fr',
    category: 'energy',
    color: {
      hex: '#FE5815',
      css: '#FE5815'
    },
    fields: {
      email: {
        type: "text"
      },
      password: {
        type: "password"
      },
      folderPath: {
        type: "folder",
        advanced: true
      }
    },
    dataType: ['bill', 'contract', 'consumption'],
    models: [Client, Contract, PaymentTerms, Home, ConsumptionStatement, Bill],
    fetchOperations: [prepareEntries, getEDFToken, fetchListerContratClientParticulier, fetchVisualiserPartenaire, fetchVisualiserAccordCommercial, fetchVisualiserCalendrierPaiement, fetchRecupereDocumentContractuelListx, fetchVisualiserHistoConso, fetchEdeliaData, updateOrCreate(logger, Client, ['clientId', 'vendor']), updateOrCreate(logger, Contract, ['number', 'vendor']), updateOrCreate(logger, PaymentTerms, ['vendor', 'clientId']), updateOrCreate(logger, Home, ['pdl']), updateOrCreate(logger, ConsumptionStatement, ['contractNumber', 'statementType', 'statementReason', 'statementCategory', 'start']), updateOrCreate(logger, Bill, ['vendor', 'number'])]
  });

  _extend = function(a, b) {
    var k, v;
    for (k in b) {
      v = b[k];
      if (v != null) {
        a[k] = v;
      }
    }
    return a;
  };

  getF = function() {
    var e, field, fields, i, len, node;
    node = arguments[0], fields = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    try {
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        node = node[field][0];
      }
    } catch (error1) {
      e = error1;
      return null;
    }
    return node;
  };

  translate = function(dict, name) {
    if (name in dict) {
      return dict[name];
    }
    return name;
  };

  edfRequestPost = function(path, body, callback) {
    return async.retry({
      times: 5,
      interval: 2000
    }, function(cb) {
      return _edfRequestPost(path, body, cb);
    }, callback);
  };

  _edfRequestPost = function(path, body, callback) {
    var xmlBody;
    K.logger.debug("called edfRequestPost");
    xmlBody = builder.buildObject(body);
    return request({
      url: 'https://rce-mobile.edf.com' + path,
      method: 'POST',
      headers: {
        'Host': 'rce-mobile.edf.com',
        'Content-Type': 'application/xml',
        'Authorization': 'Basic ' + 'QUVMTU9CSUxFX0FuZHJvaWRfVjE6QUVMTU9CSUxFX0FuZHJvaWRfVjE=',
        'Accept-Encoding': 'gzip',
        'Content-Length': xmlBody.length
      },
      body: xmlBody,
      gzip: true
    }, function(err, response, data) {
      if (err) {
        K.logger.error(JSON.stringify(err));
      }
      if (err) {
        return callback('request error');
      }
      return parser.parseString(data, function(err, result) {
        if (err) {
          return callback('request error');
        }
        return callback(null, result);
      });
    });
  };

  getEdelia = function(accessToken, path, callback) {
    return request.get('https://api.edelia.fr/authorization-proxy/api/v1/' + path, {
      auth: {
        bearer: accessToken
      },
      json: true
    }, callback);
  };

}).call(this);

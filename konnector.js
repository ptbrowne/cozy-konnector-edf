// Generated by CoffeeScript 1.12.5
(function() {
  var BaseKonnector, Bill, Client, ConsumptionStatement, Contract, DOMAIN, Home, K, PaymentTerms, _edfRequestOptions, _extend, async, buildNotifContent, builder, displayData, edfRequestPost, fetchEdeliaData, fetchEdeliaElecIndexes, fetchEdeliaGasIndexes, fetchEdeliaMonthlyElecConsumptions, fetchEdeliaMonthlyGasConsumptions, fetchEdeliaProfile, fetchEdeliaSimilarHomeYearlyElecComparisions, fetchEdeliaSimilarHomeYearlyGasComparisions, fetchEdeliaToken, fetchListerContratClientParticulier, fetchVisualiserAccordCommercial, fetchVisualiserCalendrierPaiement, fetchVisualiserFacture, fetchVisualiserHistoConso, fetchVisualiserPartenaire, fetcher, filterExisting, getEDFToken, getEdelia, getF, konnectorLibs, logger, moment, parser, prepareEntries, request, saveBills, saveDataAndFile, translate, updateOrCreate, xml2js,
    slice = [].slice;

  xml2js = require('xml2js');

  request = require('request');

  async = require('async');

  moment = require('moment');

  updateOrCreate = require('./lib/update_or_create');

  konnectorLibs = require('cozy-konnector-libs');

  fetcher = konnectorLibs.fetcher;

  BaseKonnector = konnectorLibs.baseKonnector;

  saveDataAndFile = require('./lib/save_data_and_file');

  filterExisting = konnectorLibs.filterExisting;

  Bill = konnectorLibs.models.bill;

  Client = require('./models/client');

  Contract = require('./models/contract');

  PaymentTerms = require('./models/payment_terms');

  ConsumptionStatement = require('./models/consumption_statement');

  Home = require('./models/home');

  parser = new xml2js.Parser();

  builder = new xml2js.Builder({
    headless: true
  });

  logger = require('printit')({
    prefix: 'EDF',
    date: true
  });

  DOMAIN = 'https://ws-mobile-particuliers.edf.com';

  getEDFToken = function(requiredFields, entries, data, callback) {
    var body, path;
    K.logger.info('getEDFToken');
    path = "/ws/authentifierUnClientParticulier_rest_V3-0/invoke";
    body = {
      "tns:msgRequete": {
        "$": {
          "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
          "xmlns:tns": "http://www.edf.fr/commerce/passerelle/pas001/authentifierUnClientParticulier/service/v3",
          "xsi:schemaLocation": "http://www.edf.fr/commerce/passerelle/pas001/authentifierUnClientParticulier/service/v3 authentifierUnClientParticulier.xsd"
        },
        "tns:enteteEntree": [
          {
            "tns:idCanal": 5
          }
        ],
        "tns:corpsEntree": [
          {
            "tns:idAppelant": requiredFields.email,
            "tns:password": requiredFields.password
          }
        ]
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var errorCode, token;
      if (err) {
        return callback(err);
      }
      errorCode = getF(result['tns:msgReponse'], 'tns:enteteSortie', 'ent:codeRetour');
      if (errorCode && errorCode !== '0000') {
        K.logger.error(getF(result, 'tns:enteteSortie', 'ent:libelleRetour '));
      }
      token = getF(result['tns:msgReponse'], 'tns:corpsSortie', 'tns:jeton');
      if (token != null) {
        K.logger.info("EDF token fetched");
        data.edfToken = token;
        return callback();
      } else {
        K.logger.error("Can't fetch EDF token");
        return callback('token not found');
      }
    });
  };

  fetchListerContratClientParticulier = function(reqFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetch listerContratClientParticulier");
    path = '/ws/listerContratClientParticulier_rest_V3-0/invoke';
    body = {
      "tns:msgRequete": {
        "$": {
          "xmlns:tns": "http://www.edf.fr/commerce/passerelle/pas072/listerContratClientParticulier/service/v3",
          "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
          "xsi:schemaLocation": "http://www.edf.fr/commerce/passerelle/pas072/listerContratClientParticulier/service/v3 listerContratClientParticulier_rest_V3-0.xsd "
        },
        "tns:EnteteEntree": {
          'tns:Jeton': data.edfToken
        },
        "tns:CorpsEntree": {
          "tns:SynchroniserSI": true
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var addressObject, bpObject, civilite, client, coHolder, coTitulaireElem, codePostal, contracts, contratElems, e, errorCode, identiteObj, nom, nomRue, numRue, prenom, resBody, ville;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result['tns:msgReponse'], 'tns:EnteteSortie', 'tns:CodeErreur');
        if (errorCode && errorCode !== 'PSC0000') {
          K.logger.error(getF(result['tns:mgsReponse'], 'tns:EnteteSortie', 'tns:LibelleErreur'));
          return callback('request error');
        }
        client = {
          vendor: 'EDF',
          docTypeVersion: K.docTypeVersion
        };
        resBody = getF(result["tns:msgReponse"], "tns:CorpsSortie", 'tns:AccordCo');
        client.numeroAcc = getF(resBody, 'tns:Numero');
        bpObject = getF(resBody, 'tns:BP');
        client.clientId = getF(bpObject, 'tns:Numero');
        addressObject = getF(resBody, 'tns:Adresse');
        if (addressObject) {
          numRue = getF(addressObject, 'tns:NumRue') || "";
          nomRue = getF(addressObject, 'tns:NomRue') || "";
          codePostal = getF(addressObject, 'tns:CodePostal') || "";
          ville = getF(addressObject, 'tns:Ville') || "";
          client.address = {
            street: numRue + " " + nomRue,
            city: ville,
            postcode: codePostal,
            country: 'FRANCE',
            formated: numRue + " " + nomRue + "\n" + codePostal + " " + ville
          };
        }
        identiteObj = getF(bpObject, 'tns:Identite');
        civilite = getF(identiteObj, 'tns:Civilite') || '';
        nom = getF(identiteObj, 'tns:Nom') || '';
        prenom = getF(identiteObj, 'tns:Prenom') || '';
        client.name = {
          prefix: civilite,
          family: nom,
          given: prenom,
          formated: prenom + " " + nom
        };
        coTitulaireElem = getF(bpObject, 'tns:IdentitePart');
        if (coTitulaireElem) {
          coHolder = {
            family: getF(coTitulaireElem, 'tns:NomCoTitulaire'),
            given: getF(coTitulaireElem, 'tns:PrenomCoTitulaire')
          };
          coHolder.formated = coHolder.given + " " + coHolder.family;
          client.coHolder = coHolder;
        }
        client.email = getF(bpObject, 'tns:Coordonnees', 'tns:Email');
        client.cellPhone = getF(bpObject, 'tns:Coordonnees', 'tns:NumTelMobile');
        contratElems = resBody['tns:Contrat'];
        contracts = contratElems.map(function(contratElem) {
          var cadranElem, contract, counter, offreSouscriteObj, releveElem, services, statement, vieContratObj;
          contract = {
            vendor: 'EDF',
            clientId: client.clientId,
            docTypeVersion: K.docTypeVersion
          };
          contract.number = getF(contratElem, 'tns:Numero');
          contract.pdl = getF(contratElem, 'tns:NumeroPDL');
          vieContratObj = getF(contratElem, 'tns:VieDuContrat');
          contract.start = getF(vieContratObj, 'tns:DateDebut');
          contract.status = getF(vieContratObj, 'tns:Statut');
          contract.end = getF(vieContratObj, 'tns:DateFin');
          contract.terminationGrounds = getF(vieContratObj, 'tns:MotifResiliation');
          offreSouscriteObj = getF(contratElem, 'tns:OffreSouscrite');
          contract.energie = translate({
            ELECTRICITE: 'Électricité',
            GAZ: 'Gaz'
          }, getF(offreSouscriteObj, 'tns:Energie'));
          contract.name = translate({
            GN_2: 'Offre Gaz naturel',
            MCGN_2: 'Mon Contrat gaz naturel',
            MCGN_PRIX_FIXE_1: 'Mon Contrat Gaz Naturel a prix fixe',
            ELECTRICITE_PRO: 'Electricite Pro',
            ELEC_DEREGULE: 'Mon Contrat Electricite',
            ELEC_PRO_PX_FIXE_1: 'Electricite Pro a Prix Fixe',
            ESSENTIEL_PRO: 'Essentiel Pro',
            OFFRE_HC_SOUPLES: 'Heures Creuses Souples',
            PRESENCE_PRO: 'Presence Pro',
            SOUPLESSE_PRO: 'Souplesse Pro',
            TARIF_BLEU: 'Tarif Bleu',
            TARIF_BLEU_PART: 'Tarif Bleu',
            ESSENTIEL_GAZ: 'Essentiel Gaz',
            GAZ: 'Mon Contrat Gaz Naturel',
            GAZ_2: 'Mon Contrat Gaz Naturel',
            GAZ_NAT_PX_FIXE_1: 'Gaz Naturel a Prix Fixe',
            PRESENCE_GAZ: 'Presence Gaz',
            SOUPLESSE_GAZ: 'Souplesse Gaz',
            TARIF_BLEU_GAZ: 'Gaz Naturel',
            TARIF_EJP_PART: 'EJP',
            OFFRE_TPN: 'TPN'
          }, getF(offreSouscriteObj, 'tns:NomOffre'));
          contract.troubleshootingPhone = getF(offreSouscriteObj, 'tns:NumeroDepannageContrat');
          switch (contract.energie) {
            case 'Électricité':
              contract.power = translate({
                PUI00: '0 kVA',
                PUI03: '3 kVA',
                PUI06: '6 kVA',
                PUI09: '9 kVA',
                PUI12: '12 kVA',
                PUI15: '15 kVA',
                PUI18: '18 kVA',
                PUI24: '24 kVA',
                PUI30: '30 kVA',
                PUI36: '36 kVA'
              }, getF(offreSouscriteObj, 'tns:Puissance'));
              contract.contractSubcategory1 = getF(offreSouscriteObj, 'tns:StructureTarifaire');
              break;
            case 'Gaz':
              contract.contractSubcategory2 = getF(offreSouscriteObj, 'tns:OptionPrix');
          }
          cadranElem = getF(contratElem, 'tns:ListeCadran');
          if (cadranElem) {
            counter = {};
            counter.comptage = getF(cadranElem, 'tns:Type');
            counter.nombreRoues = getF(cadranElem, 'tns:NombreRoues');
            counter.dernierIndex = getF(cadranElem, 'tns:DernierIndex');
            counter.type = getF(contratElem, 'tns:DonneesTechniques', 'tns:TypeCompteur');
            contract.counter = counter;
            contract.annualConsumption = getF(cadranElem, 'tns:ConsommationAnnuelle');
          }
          contract.peakHours = getF(contratElem, 'tns:DonneesTechniques', 'tns:HorrairesHC');
          releveElem = getF(contratElem, 'tns:Releve');
          if (releveElem) {
            statement = {};
            statement.prochaineReleve = getF(releveElem, 'tns:ProchaineDateReleveReelle');
            statement.saisieReleveConfiance = getF(releveElem, 'tns:SaisieRC');
            statement.dateFermetureReleveConfiance = getF(releveElem, 'tns:DateFermetureRC');
            statement.prochaineDateOuvertureReleveConfiance = getF(releveElem, 'tns:ProchaineDateOuvertureRC');
            statement.prochaineDateFermetureReleveConfiance = getF(releveElem, 'tns:ProchaineDateFermetureRC');
            statement.prochaineDateFermetureReelle = getF(releveElem, 'tns:ProchaineDateFermetureReelle');
            statement.saisieSuiviConso = getF(releveElem, 'tns:SaisieSC');
            statement.prochaineDateOuvertureSaisieConso = getF(releveElem, 'tns:ProchaineDateOuvertureSC');
            contract.statement = statement;
          }
          contract.services = [];
          if (contratElem['tns:ServicesSouscrits']) {
            services = contratElem['tns:ServicesSouscrits'].map(function(serviceElem) {
              var service;
              service = {
                nom: getF(serviceElem, 'tns:NomService'),
                activ: getF(serviceElem, 'tns:Etat')
              };
              return service;
            });
            contract.services = contract.services.concat(services);
          }
          if (resBody['tns:ServicesSouscrits']) {
            services = resBody['tns:ServicesSouscrits'].map(function(serviceElem) {
              var service;
              service = {
                nom: getF(serviceElem, 'tns:nomService'),
                start: getF(serviceElem, 'tns:dateSouscription'),
                activ: getF(serviceElem, 'tns:statut')
              };
              return service;
            });
            contract.services = contract.services.concat(services);
          }
          return contract;
        });
        K.logger.info("Fetched listerContratClientParticulier");
        entries.clients.push(client);
        entries.contracts = contracts;
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetching listerContratClientParticulier", e);
        return callback(e);
      }
    });
  };

  fetchVisualiserPartenaire = function(requiredFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetchVisualiserPartenaire");
    path = '/ws/visualiserPartenaire_rest_V2-0/invoke';
    body = {
      'msgRequete': {
        '$': {
          'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserPartenaire/service/v2 C:\\HMN\\EDFMoiV2\\WSDL" + "\\passerelle\\passerelle\\css\\visualiserPartenaire\\service" + "\\v2\\visualiserPartenaire.xsd",
          'xmlns': "http://www.edf.fr/commerce/passerelle/css/" + "visualiserPartenaire/service/v2",
          'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete",
          'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
        },
        'enteteEntree': {
          'ent:jeton': data.edfToken
        },
        'corpsEntree': {
          'numeroBp': entries.clients[0].clientId
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var address, addressElem, client, contact, contactElem, coordonneesElem, e, errorCode, partnerElem;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result, 'ns:enteteSortie', 'ent:codeRetour');
        if (errorCode && errorCode !== '0') {
          K.logger.error(getF(result, 'tns:enteteSortie', 'tns:libelleRetour'));
          return callback();
        }
        partnerElem = getF(result["ns:msgReponse"], "ns:corpsSortie", "ns:partenaire");
        client = {};
        coordonneesElem = getF(partnerElem, 'ns:coordonnees');
        client.cellPhone = getF(coordonneesElem, 'ns:NumTelMobile');
        client.homePhone = getF(coordonneesElem, 'ns:NumTelFixe');
        client.email = getF(coordonneesElem, 'ns:Email');
        client.loginEmail = getF(coordonneesElem, 'ns:EmailAEL');
        contactElem = getF(partnerElem, 'ns:centreContact');
        contact = {};
        contact.title = getF(contactElem, 'ns:gsr');
        contact.phone = getF(contactElem, 'ns:telephone');
        addressElem = getF(contactElem, 'ns:adresse');
        if (addressElem) {
          address = {};
          address.street = getF(addressElem, 'ns:nomRue');
          address.postcode = getF(addressElem, 'ns:codePostal');
          address.city = getF(addressElem, 'ns:ville');
          address.formated = ("" + address.street) + ("\n" + address.postcode + " " + address.city);
          contact.address = address;
        }
        client.commercialContact = contact;
        entries.clients[0] = _extend(entries.clients[0], client);
        K.logger.info("Fetched visualiserPartenaire.");
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetching visualiserPartenaire.");
        K.logger.error(e);
        return callback(e);
      }
    });
  };

  fetchVisualiserAccordCommercial = function(requiredFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetchVisualiserAccordCommercial");
    path = '/ws/visualiserAccordCommercial_rest_sso_V3-0/invoke';
    body = {
      "visualiserAccordCommercialRequest": {
        "$": {
          "xmlns": "http://www.edf.fr/psc/0122/v3/visualiserAccordCommercial",
          "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
          "xsi:schemaLocation": "http://www.edf.fr/psc/0122/v3/visualiserAccordCommercial visualiserAccordCommercial.xsd"
        },
        "jeton": data.edfToken,
        "numeroBp": entries.clients[0].clientId,
        "numeroAcc": entries.clients[0].numeroAcc,
        "applicationAppelante": "EDFETMOI"
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var acoElem, bankAddress, bankDetails, e, errorCode, paymentTerms, services, servicesElem;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result['tns:visualiserAccordCommercialResponse'], "tns:responseWebService", "tns:CodeEtatService");
        if (errorCode && errorCode !== 'PSC0000') {
          K.logger.error(getF(result['tns:visualiserAccordCommercialResponse'], "tns:responseWebService", "tns:LibelleEtatService"));
          return callback();
        }
        acoElem = getF(result['tns:visualiserAccordCommercialResponse'], "tns:responseWebService", "tns:listeAccordsCommerciaux", "tns:item");
        paymentTerms = {
          vendor: 'EDF',
          clientId: entries.clients[0].clientId,
          docTypeVersion: K.docTypeVersion
        };
        bankDetails = {
          iban: getF(acoElem, 'tns:banque', 'tns:iban'),
          holder: getF(acoElem, 'tns:compte', 'tns:titulaire'),
          bank: getF(acoElem, "tns:banque", "tns:nom")
        };
        bankAddress = {
          street: getF(acoElem, 'tns:banque', 'tns:numNomRue'),
          city: getF(acoElem, 'tns:banque', 'tns:codePostalVille'),
          country: getF(acoElem, 'tns:banque', 'tns:pays')
        };
        bankAddress.formated = ("" + bankAddress.street) + ("\n" + bankAddress.city + " " + bankAddress.country);
        bankDetails.bankAddress = bankAddress;
        paymentTerms.encryptedBankDetails = JSON.stringify(bankDetails);
        paymentTerms.balance = getF(acoElem, 'tns:detail', 'tns:solde');
        paymentTerms.paymentMeans = getF(acoElem, 'tns:detail', 'tns:modeEncaissement');
        paymentTerms.modifBankDetailsAllowed = getF(acoElem, 'tns:detail', 'tns:modifIBANAutorisee');
        paymentTerms.dernierReglement = {
          date: getF(acoElem, 'tns:dernierReglement', 'tns:date'),
          amount: getF(acoElem, 'tns:dernierReglement', 'tns:montant'),
          type: getF(acoElem, 'tns:dernierReglement', 'tns:type')
        };
        paymentTerms.billFrequency = getF(acoElem, 'tns:facturation', 'tns:periodicite');
        paymentTerms.nextBillDate = getF(acoElem);
        paymentTerms.idPayer = getF(acoElem, 'tns:numeroPayeur');
        paymentTerms.payerDivergent = getF(acoElem, 'tns:payeurDivergent');
        servicesElem = getF(acoElem, 'tns:services')['tns:item'];
        services = servicesElem.map(function(serviceElem) {
          var service;
          service = {};
          service.name = getF(serviceElem, 'tns:nomService');
          service.status = getF(serviceElem, 'tns:etat');
          service.valueSubscribed = getF(serviceElem, 'tns:valeurSouscrite');
          service.valuesAvailable = serviceElem['tns:valeursPossibles'];
          return service;
        });
        entries.paymenttermss.push(paymentTerms);
        entries.contracts.forEach(function(contract) {
          return contract.services = contract.services.concat(services);
        });
        K.logger.info("Fetched visualiserAccordCommercial.");
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetching visualiserAccordCommercial.");
        K.logger.error(e);
        return callback(e);
      }
    });
  };

  fetchVisualiserCalendrierPaiement = function(requiredFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetchVisualiserCalendrierPaiement");
    path = '/ws/visualiserCalendrierPaiement_rest_V2-0/invoke';
    body = {
      'message:msgRequete': {
        '$': {
          'xsi:schemaLocation': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserCalendrierPaiement/service/v2 C:\\HMN\\" + "EDFMoiV2\\WSDL\\passerelle\\passerelle\\css\\" + "visualiserCalendrierPaiement\\service\\v2\\" + "visualiserCalendrierPaiement.xsd",
          'xmlns:message': "http://www.edf.fr/commerce/passerelle/css/" + "visualiserCalendrierPaiement/service/v2",
          'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" + "v2/entete",
          'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
        },
        'message:enteteEntree': {
          'ent:jeton': data.edfToken
        },
        'message:corpsEntree': {
          'message:numeroBp': entries.clients[0].clientId,
          'message:numeroAcc': entries.clients[0].numeroAcc
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var e, errorCode, listeEcheances, paymentSchedules;
      if (err) {
        return callback(err);
      }
      try {
        errorCode = getF(result, 'ns:msgReponse', 'ns:enteteSortie', 'ent:codeRetour');
        if (errorCode && errorCode !== '0') {
          K.logger.error(getF(result, 'ns:msgReponse', 'ns:enteteSortie', 'ent:libelleRetour'));
          return callback();
        }
        listeEcheances = getF(result["ns:msgReponse"], "ns:corpsSortie", "ns:calendrierDePaiement");
        if (!(listeEcheances && listeEcheances['ns:listeEcheances'] && listeEcheances['ns:listeEcheances'].length > 0)) {
          K.logger.warn('No payment schedules');
          return callback();
        }
        listeEcheances = listeEcheances["ns:listeEcheances"];
        paymentSchedules = listeEcheances.map(function(echeance) {
          var amountElec, amountGaz, doc;
          amountGaz = parseFloat(getF(echeance, "ns:montantGaz"));
          amountElec = parseFloat(getF(echeance, "ns:montantElec"));
          if (isNaN(amountGaz)) {
            amountGaz = 0;
          }
          if (isNaN(amountElec)) {
            amountElec = 0;
          }
          doc = {
            number: parseInt(getF(echeance, "ns:numeroEcheance")),
            receiptDate: getF(echeance, "ns:dateEncaissement"),
            scheduleDate: getF(echeance, "ns:DateEcheance"),
            paid: getF(echeance, "ns:paiement") === 'EFFECTUE',
            amount: amountGaz + amountElec,
            amountGas: amountGaz,
            amountElectricity: amountElec
          };
          return doc;
        });
        if (!entries.paymenttermss[0]) {
          entries.paymenttermss[0] = {
            vendor: 'EDF',
            clientId: entries.clients[0].clientId,
            docTypeVersion: K.docTypeVersion
          };
        }
        entries.paymenttermss[0].paymentSchedules = paymentSchedules;
        K.logger.info(("Fetched " + paymentSchedules.length + " ") + "from fetchVisualiserCalendrierPaiement");
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetchVisualiserCalendrierPaiement");
        K.logger.error(e);
        return callback(e);
      }
    });
  };


  /*
  fetchRecupereDocumentContractuelListx = (reqFields, entries, data, callback) ->
      K.logger.info "fetchRecupereDocumentContractuelListx"
      path = '/ws/recupererDocumentContractuelListx_rest_V1-0/invoke'
      body =
          'ns:msgRequete':
              '$':
                  'xmlns:dicoPAS': "http://www.edf.fr/commerce/passerelle/" +
                  "commun/v2/dico"
                  'xmlns:dico': "http://www.edf.fr/psc/pscmaxsd/commun/v1/dico"
                  'xmlns:ns': "http://www.edf.fr/commerce/passerelle/psc/" +
                  "recupererDocumentContractuelListx/service/v1"
                  'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" +
                  "v2/entete"
  
              'ns:jeton': data.edfToken
              'ns:options': [
                  'ns:cle': 'id'
                  'ns:valeur': 'pscedfmoi'
              ,
                  'ns:cle': 2
                  'ns:valeur': entries.clients[0].clientId
              ,
                  'ns:cle': 6
                  'ns:valeur': 'Facture'
              ]
  
      edfRequestPost path, body, (err, result) ->
          return callback err if err
  
          bills = []
          try
              documents = result["ns:msgReponse"]["ns:docubase"][0]["ns:document"]
  
              bills = documents.map (elem) ->
                  bill =
                      vendor: 'EDF'
                      clientId: entries.clients[0].clientId
                       * TODO: hack to force download, bad because duplicate URL !
                      pdfurl: 'https://rce-mobile.edf.com' + '/ws/recupererDocumentContractuelGet_rest_V1-0/invoke'
                      docTypeVersion: K.docTypeVersion
  
                  bill.date = moment getF(elem, 'ns:datecre'), 'YYYYMMDD'
  
                  for option in elem['ns:category']
                      key = getF option, 'ns:id'
                      value = getF option, 'ns:valeur'
  
                      switch key
                          when '4' then bill.number = value
                          when '7' then bill.amount = Number value
  
                  return bill
  
              entries.fetched = bills
              K.logger.info "Fetched #{bills.length} bills"
              callback()
          catch e
              K.logger.error "While fetchRecupereDocumentContractuelListx"
              K.logger.error e
              callback e
   */

  fetchVisualiserFacture = function(reqFields, entries, data, callback) {
    var body, path;
    K.logger.info("fetchVisualiserFacture");
    path = '/ws/visualiserFacture_rest_V3-0/invoke';
    body = {
      "tns:msgRequete": {
        "$": {
          "xmlns:tns": "http://www.edf.fr/commerce/passerelle/pas023/visualiserFacture/service/v2"
        },
        "visualiserFactureRequest": {
          "numeroBp": entries.clients[0].clientId,
          "jeton": data.edfToken,
          "numeroAcc": entries.clients[0].numeroAcc,
          "dateRecherche": "1900-01-01"
        }
      }
    };
    return edfRequestPost(path, body, function(err, result) {
      var bills, documents, e, errorCode;
      if (err) {
        return callback(err);
      }
      bills = [];
      try {
        errorCode = getF(result["tns:msgReponse"], "visualiserFactureResponse", "responseWebService", "codeErreur");
        if (errorCode && errorCode !== '0') {
          K.logger.error(getF(result["tns:msgReponse"], "visualiserFactureResponse", "responseWebService", "libelleErreur"));
          return callback();
        }
        documents = getF(result["tns:msgReponse"], "visualiserFactureResponse", "responseWebService", "listeFactures")["item"];
        bills = documents.map(function(elem) {
          var bill, details;
          details = getF(elem, "resume");
          bill = {
            vendor: 'EDF',
            clientId: entries.clients[0].clientId,
            title: getF(details, "type"),
            number: getF(elem, "numeroFacture"),
            date: moment(getF(details, "dateEmission"), 'YYYY-MM-DD'),
            paymentDueDate: getF(details, "dateEcheance"),
            scheduledPaymentDate: getF(details, "datePrelevement"),
            totalPaymentDue: getF(details, "montantFactureFraiche"),
            value: getF(details, "montantReclame"),
            balanceBeforeInvoice: getF(details, "soldeAvantFacture"),
            pdfurl: DOMAIN + '/ws/recupererDocumentContractuelGet_rest_V1-0/invoke',
            docTypeVersion: K.docTypeVersion
          };
          return bill;
        });
        entries.fetched = bills;
        K.logger.info("Fetched " + bills.length + " bills");
        return callback();
      } catch (error1) {
        e = error1;
        K.logger.error("While fetchVisualiserFacture");
        K.logger.error(e);
        return callback(e);
      }
    });
  };

  fetchVisualiserHistoConso = function(requiredFields, entries, data, callback) {
    K.logger.info("fetchVisualiserHistoConso");
    return async.mapSeries(entries.contracts, function(contract, cb) {
      var body, path;
      path = '/ws/visualiserHistoConso_rest_V3-0/invoke';
      body = {
        'message:msgRequete': {
          '$': {
            'xsi:schemaLocation': "http://www.edf.fr/commerce/" + "passerelle/css/visualiserHistoConso/service/v2 C:\\HMN" + "\\EDFMoiV2\\WSDL\\passerelle\\passerelle\\css" + "\\visualiserHistoConso\\service\\v2\\" + "visualiserHistoConso.xsd",
            'xmlns:message': "http://www.edf.fr/commerce/passerelle/" + "css/visualiserHistoConso/service/v2",
            'xmlns:ent': "http://www.edf.fr/commerce/passerelle/" + "commun/v2/entete",
            'xmlns:xsi': "http://www.w3.org/2001/XMLSchema-instance"
          },
          'message:enteteEntree': {
            'ent:jeton': data.edfToken
          },
          'message:corpsEntree': {
            'message:numeroBp': entries.clients[0].clientId,
            'message:numeroContrat': contract.number
          }
        }
      };
      return edfRequestPost(path, body, function(err, result) {
        var consoElems, e, errorCode, res;
        if (err) {
          return callback(err);
        }
        try {
          errorCode = getF(result, 'ns:enteteSortie', 'ent:codeRetour');
          if (errorCode && errorCode !== '0') {
            K.logger.error(getF(result, 'tns:enteteSortie', 'tns:libelleRetour'));
            return callback();
          }
          if (!("ns:corpsSortie" in result["ns:msgReponse"])) {
            K.logger.info("No histoConsos to fetch");
            return callback(null, []);
          }
          consoElems = result["ns:msgReponse"]["ns:corpsSortie"][0]["ns:listeHistoDeConso"];
          res = consoElems.map(function(consoElem) {
            var doc;
            doc = {
              contractNumber: contract.number,
              billNumber: getF(consoElem, 'ns:numeroFacture'),
              start: getF(consoElem, 'ns:dateDebut'),
              end: getF(consoElem, 'ns:dateFin'),
              value: getF(consoElem, 'ns:listeConsommation', 'ns:valeur'),
              statementType: getF(consoElem, 'ns:typeReleve'),
              statementCategory: getF(consoElem, 'ns:categorieReleve'),
              statementReason: getF(consoElem, 'ns:motifReleve'),
              docTypeVersion: K.docTypeVersion
            };
            return doc;
          });
          return cb(null, res);
        } catch (error1) {
          e = error1;
          K.logger.error("While fetching visualiserHistoConso.");
          K.logger.error(e);
          return cb(e);
        }
      });
    }, function(err, results) {
      if (err) {
        return callback(err);
      }
      entries.consumptionstatements = results.reduce(function(agg, result) {
        return agg.concat(result);
      }, []);
      K.logger.info(("Fetched " + entries.consumptionstatements.length) + " consumptionStatements");
      return callback();
    });
  };


  /*
  fetchPDF = (token, client, billNumber, callback) ->
      K.logger.info "fetchPDF"
  
      path = '/ws/recupererDocumentContractuelGet_rest_V1-0/invoke'
      body =
          'ns:msgRequete':
              '$':
                  'xmlns:dicoPAS': "http://www.edf.fr/commerce/passerelle/" +
                  "commun/v2/dico"
                  'xmlns:dico': "http://www.edf.fr/psc/pscmaxsd/commun/v1/dico"
                  'xmlns:ns': "http://www.edf.fr/commerce/passerelle/psc/" +
                  "recupererDocumentContractuelGet/service/v1"
                  'xmlns:ent': "http://www.edf.fr/commerce/passerelle/commun/" +
                  "v2/entete"
  
              'ns:jeton': token
              'ns:options': [
                  'ns:cle': 'id'
                  'ns:valeur': 'pscedfmoi'
              ,
                  'ns:cle': 2
                  'ns:valeur': client.clientId
              ,
                  'ns:cle': 4
                  'ns:valeur': billNumber
              ,
                  'ns:cle': 6
                  'ns:valeur': 'Facture'
              ]
  
      edfRequestPost path, body, (err, result) ->
          return callback err if err
          K.logger.info "pdf fetched"
          base64PDF = getF result['ns:msgReponse'], \
                      'ns:docubase', 'ns:documentPDF', 'ns:pdf'
          callback null, base64PDF
   */

  saveBills = function(requiredFields, entries, data, callback) {
    var options;
    options = {};
    options.vendor = 'edf';
    options.requestoptions = function(bill) {
      var body, path;
      path = '/ws/recupererDocumentContractuelGet_rest_V1-0/invoke';
      body = {
        "dico:getRequest": {
          "$": {
            "xmlns:dico": "http://www.edf.fr/psc/pscma100/recupererDocumentContractuel/service/v1",
            "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
            "xsi:schemaLocation": "http://www.edf.fr/psc/pscma100/recupererDocumentContractuel/service/v1 recupererDocumentContractuel.xsd"
          },
          "getRequest": {
            "options": [
              {
                "cle": "id",
                "valeur": "pscedfmoi"
              }, {
                "cle": 2,
                "valeur": entries.clients[0].clientId
              }, {
                "cle": 4,
                "valeur": bill.number
              }, {
                "cle": 6,
                "valeur": "Facture"
              }
            ]
          },
          "numeroBp": entries.clients[0].clientId,
          "jeton": data.edfToken
        }
      };
      return _edfRequestOptions(path, body);
    };
    options.parseoptions = function(data) {
      return new Promise(function(resolve, reject) {
        return parser.parseString(data, function(err, result) {
          var base64PDF;
          if (err) {
            return reject('request error');
          }
          base64PDF = getF(result['rdc:getResponse'], 'getResponse', 'docubase', 'documentPDF', 'pdf');
          return resolve({
            data: base64PDF,
            contentType: "application/pdf"
          });
        });
      });
    };
    return saveDataAndFile(logger, Bill, options, ['EDF'])(requiredFields, entries, data, callback);
  };

  fetchEdeliaToken = function(requiredFields, entries, data, callback) {
    K.logger.info("fetchEdeliaToken");
    return request.post('https://api.edelia.fr/authorization-server/oauth/token', {
      form: {
        client_id: 'sha1pae0Pahngee6uwiphooDie7thaiquahf2xohd6IeFeiphi9ziu0uw3am',
        grant_type: 'edf_sso',
        jeton_sso: data.edfToken,
        bp: entries.clients[0].clientId,
        pdl: data.contract.pdl
      },
      json: true
    }, function(err, response, result) {
      if (err) {
        K.logger.error('While fetching edelia token.');
        K.logger.error(err);
        return callback(err);
      }
      K.logger.info('Fetched edelia token');
      data.edeliaToken = result.access_token;
      return callback();
    });
  };

  fetchEdeliaProfile = function(requiredFields, entries, data, callback) {
    K.logger.info("fetchEdeliaProfile");
    return getEdelia(data.edeliaToken, '/sites/-/profiles/simple?ts=' + new Date().toISOString(), function(err, response, obj) {
      var doc, e, error;
      error = null;
      try {
        if (!err && !obj) {
          err = 'no import performed';
        }
        if (err) {
          K.logger.error('While fetchEdeliaProfile');
          K.logger.error(err);
          throw err;
        }
        if (obj.errorCode && obj.errorCode === "403") {
          data.noEdelia = true;
          K.logger.warn("No edelia: " + obj.errorDescription);
          throw new Error('no edelia');
        }
        doc = {
          pdl: data.pdl,
          beginTs: obj.beginTs,
          isProfileValidated: obj.isProfileValidated,
          housingType: obj.housingType,
          residenceType: obj.residenceType,
          occupationType: obj.occupationType,
          constructionDate: obj.constructionDate,
          isBBC: obj.isBBC,
          surface: obj.surfaceInSqMeter,
          occupantsCount: obj.noOfOccupants,
          principalHeatingSystemType: obj.principalHeatingSystemType,
          sanitoryHotWaterType: obj.sanitoryHotWaterType,
          docTypeVersion: K.docTypeVersion
        };
        entries.homes.push(doc);
        return K.logger.info('Fetched fetchEdeliaProfile');
      } catch (error1) {
        e = error1;
        return error = e;
      } finally {
        callback(error);
      }
    });
  };

  fetchEdeliaMonthlyElecConsumptions = function(requiredFields, entries, data, callback) {
    if (data.noEdelia) {
      return callback();
    }
    K.logger.info("fetchEdeliaMonthlyElecConsumptions");
    return getEdelia(data.edeliaToken, "/sites/-/monthly-elec-consumptions?" + "begin-month=2012-01&" + ("end-month=" + (moment().add(1, 'month').format('YYYY-MM')) + "&ended=false"), function(err, response, obj) {
      var e, error, statements;
      error = null;
      try {
        if (response.statusCode === 404 || response.statusCode === 500) {
          K.logger.warn('No EdeliaMonthlyElecConsumptions');
          data.noElec = true;
          throw null;
        }
        if (err) {
          K.logger.error('Wihle fetchEdeliaMonthlyElecConsumptions');
          K.logger.error(err);
          throw err;
        }
        statements = [];
        data.consumptionStatementByMonth = {};
        statements = statements.concat(obj.monthlyElecEnergies.map(function(mee) {
          var doc;
          doc = {
            docTypeVersion: K.docTypeVersion,
            contractNumber: data.contract.number,
            start: mee.beginDay,
            end: mee.endDay,
            value: mee.consumption.energy,
            statementType: 'estime',
            statementCategory: 'edelia',
            statementReason: 'EdeliaMonthlyElecConsumption',
            period: mee.month,
            cost: mee.totalCost,
            costsByCategory: mee.consumption.costsByTariffHeading,
            valuesByCategory: mee.consumption.energiesByTariffHeading
          };
          doc.costsByCategory.standing = mee.standingCharge;
          data.consumptionStatementByMonth[mee.month] = doc;
          return doc;
        }));
        data.consumptionStatementByYear = {};
        statements = statements.concat(obj.yearlyElecEnergies.map(function(yee) {
          var doc;
          doc = {
            docTypeVersion: K.docTypeVersion,
            contractNumber: data.contract.number,
            start: yee.beginDay,
            end: yee.endDay,
            value: yee.consumption.energy,
            statementType: 'estime',
            statementCategory: 'edelia',
            statementReason: 'EdeliaYearlyElecConsumption',
            period: yee.year,
            cost: yee.totalCost,
            costsByCategory: yee.consumption.costsByTariffHeading,
            valuesByCategory: yee.consumption.energiesByTariffHeading
          };
          doc.costsByCategory.standing = yee.standingCharge;
          data.consumptionStatementByYear[yee.year] = doc;
          return doc;
        }));
        if (statements.length !== 0) {
          entries.consumptionstatements = entries.consumptionstatements.concat(statements);
        }
        return K.logger.info('Fetched fetchEdeliaMonthlyElecConsumptions');
      } catch (error1) {
        e = error1;
        return error = e;
      } finally {
        callback(error);
      }
    });
  };

  fetchEdeliaSimilarHomeYearlyElecComparisions = function(requiredFields, entries, data, callback) {
    if (data.noEdelia || data.noElec) {
      return callback();
    }
    K.logger.info("fetchEdeliaSimilarHomeYearlyElecComparisions");
    return getEdelia(data.edeliaToken, "/sites/-/similar-home-yearly-elec-comparisons?begin-year=2012", function(err, response, objs) {
      var e, error;
      error = null;
      try {
        if (response.statusCode === 404 || response.statusCode === 500) {
          K.logger.warn('No EdeliaSimilarHomeYearlyElecComparisions');
          data.noElec = true;
          throw null;
        }
        if (err) {
          K.logger.error('While fetchEdeliaSimilarHomeYearlyElecComparisions');
          K.logger.error(err);
          throw err;
        }
        objs.forEach(function(obj) {
          var statement;
          statement = data.consumptionStatementByYear[obj.year];
          if (!statement) {
            K.logger.warn("No yearly statement for " + obj.date.year);
            return;
          }
          return statement.similarHomes = {
            site: obj.energies.site,
            average: obj.energies.similarHomes.SH_AVERAGE_CONSUMING,
            least: obj.energies.similarHomes.SH_LEAST_CONSUMING
          };
        });
        K.logger.info('Fetched fetchEdeliaSimilarHomeYearlyElecComparisions');
      } catch (error1) {
        e = error1;
        error = e;
      }
      delete data.consumptionStatementByYear;
      return callback(error);
    });
  };

  fetchEdeliaElecIndexes = function(requiredFields, entries, data, callback) {
    if (data.noEdelia || data.noElec) {
      return callback();
    }
    K.logger.info("fetchEdeliaElecIndexes");
    return getEdelia(data.edeliaToken, "/sites/-/elec-indexes?begin-date=2012-01-01&" + ("end-date=" + (moment().format('YYYY-MM-DD')) + "&types="), function(err, response, objs) {
      var e, error;
      error = null;
      try {
        if (response.statusCode === 404) {
          K.logger.warn('No EdeliaElecIndexes');
          throw null;
        }
        if (err) {
          K.logger.error('Wihle fetchEdeliaElecIndexes');
          K.logger.error(err);
          throw err;
        }
        objs.forEach(function(obj) {
          var statement;
          statement = data.consumptionStatementByMonth[obj.date.slice(0, 7)];
          if (!statement) {
            K.logger.warn("No monthly statement for" + (obj.date.slice(0, 7)));
            return;
          }
          statement.statements = statement.statements || [];
          return statement.statements.push(obj);
        });
        K.logger.info('Fetched fetchEdeliaElecIndexes');
      } catch (error1) {
        e = error1;
        error = e;
      }
      delete data.consumptionStatementByMonth;
      return callback(error);
    });
  };

  fetchEdeliaMonthlyGasConsumptions = function(requiredFields, entries, data, callback) {
    if (data.noEdelia) {
      return callback();
    }
    K.logger.info("fetchEdeliaMonthlyGasConsumptions");
    return getEdelia(data.edeliaToken, "/sites/-/monthly-gas-consumptions?begin-month=2012-01&" + ("end-month=" + (moment().add(1, 'month').format('YYYY-MM')) + "&ended=false"), function(err, response, obj) {
      var e, error, ref, statements;
      error = null;
      try {
        if (response.statusCode === 404) {
          K.logger.warn('No EdeliaMonthlyGasConsumptions');
          data.noGas = true;
          throw null;
        }
        if (err) {
          K.logger.error('Wihle fetchEdeliaMonthlyGasConsumptions');
          K.logger.error(err);
          throw err;
        }
        statements = [];
        data.consumptionStatementByMonth = {};
        statements = (ref = obj.monthlyGasEnergies) != null ? ref.map(function(mee) {
          var doc;
          doc = {
            docTypeVersion: K.docTypeVersion,
            contractNumber: data.contract.number,
            start: mee.beginDay,
            end: mee.endDay,
            value: mee.consumption.energy,
            statementType: 'estime',
            statementCategory: 'edelia',
            statementReason: 'EdeliaMonthlyGasConsumption',
            period: mee.month,
            cost: mee.totalCost,
            costsByCategory: {
              consumption: mee.consumption.cost,
              standing: mee.standingCharge
            }
          };
          data.consumptionStatementByMonth[mee.month] = mee;
          return doc;
        }) : void 0;
        data.consumptionStatementByYear = {};
        statements = statements.concat(obj.yearlyGasEnergies.map(function(yee) {
          var doc;
          doc = {
            docTypeVersion: K.docTypeVersion,
            contractNumber: data.contract.number,
            start: yee.beginDay,
            end: yee.endDay,
            value: yee.consumption.energy,
            statementType: 'estime',
            statementCategory: 'edelia',
            statementReason: 'EdeliaYearlyGasConsumption',
            period: yee.year,
            cost: yee.totalCost,
            costsByCategory: {
              consumption: yee.consumption.cost,
              standing: yee.standingCharge
            }
          };
          data.consumptionStatementByYear[yee.year] = doc;
          return doc;
        }));
        if (statements.length !== 0) {
          entries.consumptionstatements = entries.consumptionstatements.concat(statements);
        }
        K.logger.info('Fetched fetchEdeliaMonthlyGasConsumptions');
      } catch (error1) {
        e = error1;
        error = e;
      }
      return callback(error);
    });
  };

  fetchEdeliaSimilarHomeYearlyGasComparisions = function(requiredFields, entries, data, callback) {
    if (data.noEdelia || data.noGas) {
      return callback();
    }
    K.logger.info("fetchEdeliaSimilarHomeYearlyGasComparisions");
    return getEdelia(data.edeliaToken, "/sites/-/similar-home-yearly-gas-comparisons?begin-year=2012", function(err, response, objs) {
      var e, error;
      error = null;
      try {
        if (response.statusCode === 404 || response.statusCode === 500) {
          K.logger.warn('No EdeliaSimilarHomeYearlyGasComparisions');
          throw null;
        }
        if (err) {
          K.logger.error('While fetchEdeliaSimilarHomeYearlyGasComparisions');
          K.logger.error(err);
          throw err;
        }
        objs.forEach(function(obj) {
          var statement;
          statement = data.consumptionStatementByYear[obj.year];
          if (!statement) {
            K.logger.warn("No yearly statement for " + obj.date.year);
            return;
          }
          return statement.similarHomes = {
            site: obj.energies.site,
            average: obj.energies.similarHomes.SH_AVERAGE_CONSUMING,
            least: obj.energies.similarHomes.SH_LEAST_CONSUMING
          };
        });
        K.logger.info('Fetched fetchEdeliaSimilarHomeYearlyGasComparisions');
      } catch (error1) {
        e = error1;
        error = e;
      }
      return callback(error);
    });
  };

  fetchEdeliaGasIndexes = function(requiredFields, entries, data, callback) {
    if (data.noEdelia || data.noGas) {
      return callback();
    }
    K.logger.info("fetchEdeliaGasIndexes");
    return getEdelia(data.edeliaToken, "/sites/-/gas-indexes?begin-date=2012-01-01&" + ("end-date=" + (moment().format('YYYY-MM-DD')) + "&types="), function(err, response, objs) {
      var e, error;
      error = null;
      try {
        if (response.statusCode === 404) {
          K.logger.warn('No EdeliaGasIndexes');
          throw null;
        }
        if (err) {
          K.logger.error('Wihle fetchEdeliaGasIndexes');
          K.logger.error(err);
          throw err;
        }
        objs.forEach(function(obj) {
          var statement;
          statement = data.consumptionStatementByMonth[obj.date.slice(0, 7)];
          if (!statement) {
            K.logger.warn("No monthly statement for" + (obj.date.slice(0, 7)));
            return;
          }
          statement.statements = statement.statements || [];
          return statement.statements.push(obj);
        });
        K.logger.info('Fetched fetchEdeliaGasIndexes');
      } catch (error1) {
        e = error1;
        error = e;
      }
      return callback(error);
    });
  };

  prepareEntries = function(requiredFields, entries, data, next) {
    entries.homes = [];
    entries.consumptionstatements = [];
    entries.contracts = [];
    entries.fetched = [];
    entries.clients = [];
    entries.paymenttermss = [];
    return next();
  };

  buildNotifContent = function(requiredFields, entries, data, next) {
    var addedList, count, docsName, message, ref;
    addedList = [];
    ref = data.created;
    for (docsName in ref) {
      count = ref[docsName];
      if (count > 0) {
        message = localization.t("notification " + docsName, {
          smart_count: count
        });
        addedList.push(message);
      }
    }
    if (addedList.length > 0) {
      entries.notifContent = addedList.join(', ');
    }
    return next();
  };


  /*
  createNewFile = (data, file, callback) ->
      attachBinary = (newFile) ->
  
           * Here file is a stream. For some weird reason, request-json requires
           * that a path field should be set before uploading.
          file.path = data.name
          newFile.attachBinary file, {"name": "file"}, (err, res, body) ->
              upload = false
              if err
                  newFile.destroy (error) ->
                      callback 'file error'
              else
                  callback null, newFile
  
       * Create file document then attach file stream as binary to that file
       * document.
      File.create data, (err, newFile) ->
          if err
              K.logger.error err
              callback 'file error'
          else
              attachBinary newFile
  
  
  saveMissingBills = (requiredFields, entries, data, callback) ->
      Bill.all (err, bills) ->
          async.eachSeries bills, (bill, cb) ->
              return cb() if ((bill.vendor isnt 'EDF') or bill.fileId)
  
              fetchPDF data.edfToken, entries.clients[0], bill.number
              , (err, base64String) ->
                  return cb err if err
  
                  binaryBill = new Buffer base64String, 'base64'
                  name = moment(bill.date).format('YYYY-MM-DD')
                  name += '-facture_EDF.pdf'
                  file = new File
                      name: name
                      mime: "application/pdf"
                      creationDate: new Date().toISOString()
                      lastModification: new Date().toISOString()
                      class: "document"
                      path: requiredFields.folderPath
                      size: binaryBill.length
  
                  Folder.mkdirp requiredFields.folderPath, (err) ->
                      return cb 'file error' if err
                      createNewFile file, binaryBill, (err, file) ->
                          return cb 'file error' if err
                          bill.updateAttributes
                              fileId: file._id
                              binaryId: file.binary?.file.id
                          , cb
          , callback
   */

  displayData = function(requiredFields, entries, data, next) {
    K.logger.info("display data");
    K.logger.info(JSON.stringify(entries, null, 2));
    K.logger.info(JSON.stringify(data, null, 2));
    return next();
  };

  fetchEdeliaData = function(requiredFields, entries, data, next) {
    return async.eachSeries(entries.contracts, function(contract, callback) {
      var importer, operations;
      data.contract = contract;
      importer = fetcher["new"]();
      operations = [fetchEdeliaToken, fetchEdeliaProfile, fetchEdeliaMonthlyElecConsumptions, fetchEdeliaSimilarHomeYearlyElecComparisions, fetchEdeliaElecIndexes, fetchEdeliaMonthlyGasConsumptions, fetchEdeliaSimilarHomeYearlyGasComparisions, fetchEdeliaGasIndexes];
      operations.forEach(function(operation) {
        return importer.use(operation);
      });
      importer.args(requiredFields, entries, data);
      return importer.fetch(function(err, fields, entries) {
        if (err && err.message !== 'no edelia') {
          K.logger.error('Error while fetching Edelia data');
          K.logger.error(err);
        }
        return callback();
      });
    }, next);
  };

  K = module.exports = BaseKonnector.createNew({
    name: 'EDF',
    slug: 'edf',
    description: 'konnector description edf',
    vendorLink: 'https://particulier.edf.fr/fr',
    category: 'energy',
    color: {
      hex: '#FE5815',
      css: '#FE5815'
    },
    fields: {
      email: {
        type: "text"
      },
      password: {
        type: "password"
      },
      folderPath: {
        type: "folder",
        advanced: true
      }
    },
    dataType: ['bill', 'contract', 'consumption'],
    models: [Client, Contract, PaymentTerms, Home, ConsumptionStatement, Bill],
    fetchOperations: [prepareEntries, getEDFToken, fetchListerContratClientParticulier, fetchVisualiserPartenaire, fetchVisualiserAccordCommercial, fetchVisualiserCalendrierPaiement, fetchVisualiserFacture, fetchVisualiserHistoConso, fetchEdeliaData, updateOrCreate(logger, Client, ['clientId', 'vendor']), updateOrCreate(logger, Contract, ['number', 'vendor']), updateOrCreate(logger, PaymentTerms, ['vendor', 'clientId']), updateOrCreate(logger, Home, ['pdl']), updateOrCreate(logger, ConsumptionStatement, ['contractNumber', 'statementType', 'statementReason', 'statementCategory', 'start']), displayData, filterExisting(logger, Bill, void 0, 'EDF'), saveBills]
  });

  _extend = function(a, b) {
    var k, v;
    for (k in b) {
      v = b[k];
      if (v != null) {
        a[k] = v;
      }
    }
    return a;
  };

  getF = function() {
    var e, field, fields, i, len, node;
    node = arguments[0], fields = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    try {
      for (i = 0, len = fields.length; i < len; i++) {
        field = fields[i];
        node = node[field][0];
      }
    } catch (error1) {
      e = error1;
      return null;
    }
    return node;
  };

  translate = function(dict, name) {
    if (name in dict) {
      return dict[name];
    }
    return name;
  };

  _edfRequestOptions = function(path, body) {
    var options, xmlBody;
    xmlBody = builder.buildObject(body);
    options = {
      url: DOMAIN + path,
      method: 'POST',
      headers: {
        'Host': 'ws-mobile-particuliers.edf.com',
        'Content-Type': 'text/xml',
        'Authorization': 'Basic ' + 'QUVMTU9CSUxFX2lQaG9uZV9WMTpBRUxNT0JJTEVfaVBob25lX1Yx',
        'Accept-Encoding': 'gzip, deflate',
        'Content-Length': xmlBody.length
      },
      body: xmlBody,
      gzip: true
    };
    return options;
  };

  edfRequestPost = function(path, body, callback) {
    K.logger.debug("called edfRequestPost");
    return request(_edfRequestOptions(path, body), function(err, response, data) {
      if (err) {
        K.logger.error(JSON.stringify(err));
      }
      if (err) {
        return callback('request error');
      }
      return parser.parseString(data, function(err, result) {
        if (err) {
          return callback('request error');
        }
        return callback(null, result);
      });
    });
  };

  getEdelia = function(accessToken, path, callback) {
    return request.get('https://api.edelia.fr/authorization-proxy/api/v1/' + path, {
      auth: {
        bearer: accessToken
      },
      json: true
    }, callback);
  };

}).call(this);
